// Copyright Zero Games. All Rights Reserved.

using System.Text;

namespace ZeroGames.ZSharp.Build.Glue;

public class ClassWriter : IDisposable, IAsyncDisposable
{

	public ClassWriter(ExportedAssemblyRegistry registry, ExportedClass exportedClass, Stream stream)
	{
		_registry = registry;
		_exportedClass = exportedClass;
		_sw = new(stream, Encoding.UTF8);
	}

	public void Dispose()
	{
		_sw.Dispose();
	}

	public async ValueTask DisposeAsync()
	{
		await _sw.DisposeAsync();
	}

	public Task WriteAsync() => Task.Run(() =>
	{
		_sw.Write(
@$"// Copyright Zero Games. All Rights Reserved.

// THIS FILE IS GENERATED BY ZSHARP.
// DO NOT MODIFY DIRECTLY!

#region GENERATED CODE

#nullable enable
#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

using ZeroGames.ZSharp.Core;
using ZeroGames.ZSharp.UnrealEngine;
{_extraUsingBlock}

namespace {_exportedClass.Namespace};

{_classAttributes}
{_classDeclaration}{_classBody}

#endregion


");
	});

	private string GetTypeModule(string type)
	{
		string[] split = type.Split('.');
		if (split.Length < 2)
		{
			return string.Empty;
		}

		return split[0];
	}

	private string GetMethodBlock(ExportedMethod method)
	{
		string accessModifier = method.IsPublic ? "public" : method.IsProtected ? "protected" : "private";
		string staticModifier = method.IsStatic ? "static " : string.Empty;
		return $"\t{accessModifier} {staticModifier}void {method.Name}(){{}}";
	}

	private string GetPropertyBlock(ExportedProperty property)
	{
		string name = property.Type.ToString();
		string nunNullableName = property.Type.ToString(false);
		bool isNullable = property.Type.IsNullable;
		string nullForgivingModifier = isNullable ? string.Empty : "!";
		string accessModifier = property.IsPublic ? "public" : property.IsProtected ? "protected" : "private";
		string getBlock = property.IsReadable ?
@$"		get
		{{
			return ({name})this.ZCall(""{property.ZCallName}"", false, {property.Index}, typeof({nunNullableName}))[3].Object{nullForgivingModifier};
		}}" : string.Empty;
		string setBlock = property.IsWritable ?
@$"
		set
		{{
			this.ZCall(""{property.ZCallName}"", true, {property.Index}, value);
		}}" : string.Empty;
		string block =
@$"	{accessModifier} {property.Type} {property.Name}
	{{
{getBlock}{setBlock}
	}}";

		return block;
	}

	private string _extraUsingBlock
	{
		get
		{
			List<string> relevantModules = [ "Core", "CoreUObject", "PhysicsCore", "InputCore", "Engine" ];

			if (_baseType is {} baseType)
			{
				relevantModules.Add(GetTypeModule(baseType));
			}
			
			relevantModules.RemoveAll(module => string.IsNullOrWhiteSpace(module) || module == _exportedClass.Module);

			return string.Join('\n', relevantModules.Distinct().Select(module => $"using {_registry.GetModuleAssembly(module)?.Name ?? throw new InvalidOperationException($"Unmapped module {module}")}.{module};"));
		}
	}

	private string _classAttributes
	{
		get
		{
			List<string> attrs = [ "[System.CodeDom.Compiler.GeneratedCode(\"ZSharp\", \"0.0.4\")]" ];
			if (_exportedClass.ConjugateRegistryId > 0)
			{
				attrs.Add($"[ConjugateRegistryId({_exportedClass.ConjugateRegistryId})]");
			}
			
			if (!string.IsNullOrWhiteSpace(_exportedClass.UnrealFieldPath))
			{
				attrs.Add($"[UnrealFieldPath(__kUnrealFieldPath)]");
			}
			
			return string.Join('\n', attrs);
		}
	}

	private string _classDeclaration
	{
		get
		{
			string? @abstract = _exportedClass.IsAbstract ? "abstract " : null;
			string @class = _exportedClass.IsInterface ? "interface " : "class ";
			string? @base = _baseType;
			string? conjugate = _hasBuildConjugate ? $"IConjugate<{_exportedClass.Name}>" : null;
			List<string?> bases = [ @base, conjugate ];
			
			string classModifiers = $"public {@abstract}partial {@class}";
			string baseTypes = string.Join(", ", bases.Where(b => b is not null));
			if (!string.IsNullOrWhiteSpace(baseTypes))
			{
				baseTypes = baseTypes.Insert(0, " : ");
			}
			return $"{classModifiers}{_exportedClass.Name}{baseTypes}";
		}
	}

	private bool _hasBuildConjugate => !_exportedClass.IsInterface && !_exportedClass.IsAbstract;

	private string? _baseType
	{
		get
		{
			if (string.IsNullOrWhiteSpace(_exportedClass.BaseType.Name))
			{
				if (_exportedClass.IsPlain)
				{
					return "PlainExportedObjectBase";
				}

				if (_exportedClass.IsClass)
				{
					return "UnrealObjectBase";
				}

				if (_exportedClass.IsStruct)
				{
					return "UnrealStructBase";
				}

				if (_exportedClass.IsInterface)
				{
					return null;
				}

				throw new InvalidOperationException($"Invalid exported class {_exportedClass.Name}");
			}

			return _exportedClass.BaseType.ToString(false);
		}
	}

	private string? _interfaceStaticField
	{
		get
		{
			if (_exportedClass.IsClass | _exportedClass.IsInterface)
			{
				return
@"	public new static string SUnrealFieldPath => __kUnrealFieldPath;
	public new static UnrealClass SStaticClass => UnrealObjectGlobals.LowLevelFindObject<UnrealClass>(__kUnrealFieldPath)!;";
			}
			if (_exportedClass.IsStruct)
			{
				return
@"	public new static string SUnrealFieldPath => __kUnrealFieldPath;
	public new static UnrealScriptStruct SStaticStruct => UnrealObjectGlobals.LowLevelFindObject<UnrealScriptStruct>(__kUnrealFieldPath)!;";
			}

			return null;
		}
	}

	private string? _interfaceInstanceField
	{
		get
		{
			if (_exportedClass.IsClass | _exportedClass.IsStruct)
			{
				return "\tpublic override string UnrealFieldPath => __kUnrealFieldPath;";
			}
			
			return null;
		}
	}

	private string? _constructorStatic
	{
		get
		{
			return
@$"	static {_exportedClass.Name}()
	{{

	}}";
		}
	}

	private string _classBody
	{
		get
		{
			StringBuilder body = new();
			
			// Methods
			foreach (var method in _exportedClass.Methods.OrderBy(method => method.IsPublic ? 1 : method.IsProtected ? 2 : 3))
			{
				string block = GetMethodBlock(method);
				body.Append(block);
				body.Append("\n\n");
			}
			
			// Properties
			foreach (var prop in _exportedClass.Properties.OrderBy(prop => prop.IsPublic ? 1 : prop.IsProtected ? 2 : 3))
			{
				string block = GetPropertyBlock(prop);
				body.Append(block);
				body.Append("\n\n");
			}

			// Intrinsics
			string userdata = _exportedClass.IsStruct ? "SStaticStruct.Unmanaged" : "IntPtr.Zero";
			string? constructorDefault = _exportedClass.IsClass || _exportedClass.IsInterface ? null : $"\tpublic {_exportedClass.Name}(){{ Unmanaged = GetOwningAlc().BuildConjugate(this, {userdata}); }}";
			string? methodBuildConjugate = _hasBuildConjugate ? $"\tpublic new static {_exportedClass.Name} BuildConjugate(IntPtr unmanaged) => new(unmanaged);" : null;
			string? constructorRed = _exportedClass.IsInterface ? null : $"\tprotected {_exportedClass.Name}(IntPtr unmanaged) : base(unmanaged){{}}";
			string? constUnrealFieldPath = string.IsNullOrWhiteSpace(_exportedClass.UnrealFieldPath) ? null : $"\tprivate const string __kUnrealFieldPath = \"{_exportedClass.UnrealFieldPath}\";";
			
			List<string?> intrinsicMethods = [ constructorDefault, methodBuildConjugate, _interfaceStaticField, _interfaceInstanceField, constructorRed/*, _constructorStatic*/, constUnrealFieldPath ];
			string intrinsicMethodBlock = string.Join('\n', intrinsicMethods.Where(m => m is not null));
			body.Append(intrinsicMethodBlock);

			if (body.Length > 0)
			{
				body.Insert(0, "\n{\n\n");
				body.Append("\n\n}");
			}
			else
			{
				body.Append(';');
			}

			return body.ToString();
		}
	}

	private ExportedAssemblyRegistry _registry;
	private ExportedClass _exportedClass;
	private StreamWriter _sw;
	
}


