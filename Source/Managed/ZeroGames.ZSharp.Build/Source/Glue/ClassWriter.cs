// Copyright Zero Games. All Rights Reserved.

using System.Text;

namespace ZeroGames.ZSharp.Build.Glue;

public class ClassWriter : IDisposable, IAsyncDisposable
{

	public ClassWriter(ExportedAssemblyRegistry registry, ExportedClass exportedClass, Stream stream)
	{
		_registry = registry;
		_exportedClass = exportedClass;
		_sw = new(stream, Encoding.UTF8);
	}

	public void Dispose()
	{
		_sw.Dispose();
	}

	public async ValueTask DisposeAsync()
	{
		await _sw.DisposeAsync();
	}

	public Task WriteAsync() => Task.Run(() =>
	{
		_sw.Write(
@$"// Copyright Zero Games. All Rights Reserved.

// THIS FILE IS GENERATED BY ZSHARP.
// DO NOT MODIFY DIRECTLY!

#region GENERATED CODE

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

using ZeroGames.ZSharp.Core;
using ZeroGames.ZSharp.UnrealEngine;
{_extraUsingBlock}

namespace {_exportedClass.Namespace};

{_classAttributes}
{_classDeclaration}{_classBody}

#endregion


");
	});

	private string GetTypeModule(string type)
	{
		string[] split = type.Split('.');
		if (split.Length < 2)
		{
			return string.Empty;
		}

		return split[0];
	}
	
	private string GetTypeName(string type)
	{
		string[] split = type.Split('.');
		return split.Length switch
		{
			1 => split[0],
			2 => split[1],
			_ => throw new InvalidOperationException($"Wrong export type name [{type}]")
		};
	}

	private string _extraUsingBlock
	{
		get
		{
			List<string> relevantModules = [ "Core", "CoreUObject", "Engine" ];

			if (_baseType is {} baseType)
			{
				relevantModules.Add(GetTypeModule(baseType));
			}
			
			relevantModules.RemoveAll(module => string.IsNullOrWhiteSpace(module) || module == _exportedClass.Module);

			return string.Join('\n', relevantModules.Distinct().Select(module => $"using {_registry.GetModuleAssembly(module)?.Name ?? throw new InvalidOperationException($"Unmapped module {module}")}.{module};"));
		}
	}

	private string _classAttributes
	{
		get
		{
			List<string> attrs = [ "[System.CodeDom.Compiler.GeneratedCode(\"ZSharp\", \"0.0.4\")]" ];
			if (_exportedClass.ConjugateRegistryId > 0)
			{
				attrs.Add($"[ConjugateRegistryId({_exportedClass.ConjugateRegistryId})]");
			}
			
			return string.Join('\n', attrs);
		}
	}

	private string _classDeclaration
	{
		get
		{
			string? @abstract = _exportedClass.Abstract ? "abstract " : null;
			string @class = _exportedClass.Interface ? "interface " : "class ";
			string? @base = _baseType;
			string? conjugate = _implementsBuildConjugate ? $"IConjugate<{_exportedClass.Name}>" : null;
			List<string?> bases = [ @base, conjugate ];
			
			string classModifiers = $"public {@abstract}partial {@class}";
			string baseTypes = string.Join(", ", bases.Where(b => b is not null));
			if (!string.IsNullOrWhiteSpace(baseTypes))
			{
				baseTypes = baseTypes.Insert(0, " : ");
			}
			return $"{classModifiers}{_exportedClass.Name}{baseTypes}";
		}
	}

	private bool _implementsBuildConjugate => !_exportedClass.Interface && !_exportedClass.Abstract;

	private string? _baseType
	{
		get
		{
			if (string.IsNullOrWhiteSpace(_exportedClass.BaseType))
			{
				if (_exportedClass.Plain)
				{
					return "PlainExportedObjectBase";
				}

				if (_exportedClass.Class)
				{
					return "UnrealObjectBase";
				}

				if (_exportedClass.Struct)
				{
					return "UnrealStructBase";
				}

				if (_exportedClass.Interface)
				{
					return null;
				}

				throw new InvalidOperationException($"Invalid exported class {_exportedClass.Name}");
			}

			return GetTypeName(_exportedClass.BaseType);
		}
	}

	private string _classBody
	{
		get
		{
			StringBuilder body = new();

			string? constructorDefault = _exportedClass.Class | _exportedClass.Interface ? null : $"\tpublic {_exportedClass.Name}(){{}}";
			string? methodBuildConjugate = _implementsBuildConjugate ? $"\tpublic new static {_exportedClass.Name} BuildConjugate(IntPtr unmanaged) => new(unmanaged);" : null;
			string? constructorRed = _exportedClass.Interface ? null : $"\tprotected {_exportedClass.Name}(IntPtr unmanaged) : base(unmanaged){{}}";
			List<string?> intrinsicMethods = [ constructorDefault, methodBuildConjugate, constructorRed ];
			string intrinsicMethodBlock = string.Join('\n', intrinsicMethods.Where(m => m is not null));
			body.Append(intrinsicMethodBlock);

			if (body.Length > 0)
			{
				body.Insert(0, "\n{\n\n");
				body.Append("\n\n}");
			}
			else
			{
				body.Append(';');
			}

			return body.ToString();
		}
	}

	private ExportedAssemblyRegistry _registry;
	private ExportedClass _exportedClass;
	private StreamWriter _sw;
	
}


