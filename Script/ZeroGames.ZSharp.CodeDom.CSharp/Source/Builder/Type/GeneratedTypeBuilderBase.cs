// Copyright Zero Games. All Rights Reserved.

using System.Reflection;

namespace ZeroGames.ZSharp.CodeDom.CSharp;

public abstract class GeneratedTypeBuilderBase<TDefinition>(string namespaceName, string typeName, string? unrealFieldPath) where TDefinition : TypeDefinitionBase
{

	public CompilationUnit Build()
	{
		CompilationUnit compilationUnit = new();
		
		compilationUnit.AddHeaderBlock(HEADER);

		string[] finalUsings =
		[
			"System.Diagnostics.CodeAnalysis",
			"ZeroGames.ZSharp.Core",
			"ZeroGames.ZSharp.Core.UnrealEngine",
			"ZeroGames.ZSharp.Core.UnrealEngine.Specifier",
			"ZeroGames.ZSharp.UnrealEngine",
			.._usings
		];
		foreach (var ns in finalUsings.Where(n => !string.IsNullOrWhiteSpace(n) && n != "System").Distinct().OrderBy(n => n))
		{
			compilationUnit.AddUsing(new(ns));
		}

		compilationUnit.Namespace = new(Namespace);
		
		TDefinition definition = AllocateTypeDefinition();
		BuildTypeDefinition(definition);
		
		foreach (var attr in _attributeBefores)
		{
			definition.AddAttributeListAfter(new AttributeDeclaration(attr.Name, attr.Arguments));
		}

		if (GenerateIntrinsicContent)
		{
			definition.AddAttributeListAfter(new AttributeDeclaration("global::System.CodeDom.Compiler.GeneratedCode", "\"Z#\"", $"\"{Assembly.GetExecutingAssembly().GetName().Version.ToString(3)}\""));
			if (HasUnrealFieldPath)
			{
				definition.AddAttributeListAfter(new AttributeDeclaration("UnrealFieldPath", HasUnrealFieldPathConst ? UNREAL_FIELD_PATH_CONST : UnrealFieldPathLiteralText));
			}
		}

		foreach (var attr in _attributeAfters)
		{
			definition.AddAttributeListAfter(new AttributeDeclaration(attr.Name, attr.Arguments));
		}

		foreach (var baseType in _baseTypes)
		{
			definition.AddBaseType(baseType);
		}
		
		ClassDefinition? outerClassDefinition = GetOuterClassDefinition();
		PreAddMainType(compilationUnit, outerClassDefinition);
		if (outerClassDefinition is not null)
		{
			outerClassDefinition.AddMember(definition);
		}
		compilationUnit.AddType(outerClassDefinition is null ? definition : outerClassDefinition);
		PostAddMainType(compilationUnit, outerClassDefinition);
		
		compilationUnit.AddEndBlock(END);

		return compilationUnit;
	}

	public void AddUsingNamespace(string ns) => _usings.Add(ns);

	protected void AddBaseTypeBefore(string baseType) => _baseTypes.Insert(0, baseType);
	protected void AddBaseTypeAfter(string baseType) => _baseTypes.Add(baseType);
	protected void AddAttributeBefore(string name, params string[]? arguments) => _attributeBefores.Add((name, arguments));
	protected void AddAttributeAfter(string name, params string[]? arguments) => _attributeAfters.Add((name, arguments));

	protected virtual ClassDefinition? GetOuterClassDefinition() => null;
	
	protected abstract TDefinition AllocateTypeDefinition();
	protected abstract void BuildTypeDefinition(TDefinition definition);

	protected virtual void PreAddMainType(CompilationUnit compilationUnit, ClassDefinition? outerClassDefinition){}
	protected virtual void PostAddMainType(CompilationUnit compilationUnit, ClassDefinition? outerClassDefinition){}
	
	protected string Namespace { get; } = namespaceName;
	protected string TypeName { get; } = typeName;
	protected string? UnrealFieldPath { get; } = unrealFieldPath;
	protected string UnrealFieldPathLiteralText => $"\"{UnrealFieldPath}\"";

	protected virtual bool GenerateIntrinsicContent => true;

	protected virtual bool HasUnrealFieldPath => true;
	protected virtual bool HasUnrealFieldPathConst => true;

	protected const string UNREAL_FIELD_PATH_CONST = "__UNREAL_FIELD_PATH";
	
	private const string HEADER =
@"// Copyright Zero Games. All Rights Reserved.

// IMPORTANT: THIS FILE IS GENERATED BY Z#. DO NOT MODIFY DIRECTLY!

#region GENERATED CODE

#nullable enable
#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
#pragma warning disable CS0628 // New protected member declared in sealed type";

	private const string END =
@"#endregion


";

	private List<string> _usings = new();
	private List<string> _baseTypes = new();
	private List<(string Name, string[]? Arguments)> _attributeBefores = new();
	private List<(string Name, string[]? Arguments)> _attributeAfters = new();

}


