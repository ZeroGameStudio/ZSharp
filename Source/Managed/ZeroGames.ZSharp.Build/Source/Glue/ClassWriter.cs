// Copyright Zero Games. All Rights Reserved.

using System.Reflection;
using System.Text;

namespace ZeroGames.ZSharp.Build.Glue;

public class ClassWriter : IDisposable, IAsyncDisposable
{

	public ClassWriter(ExportedAssemblyRegistry registry, ExportedClass exportedClass, Stream stream)
	{
		_registry = registry;
		_exportedClass = exportedClass;
		_sw = new(stream, Encoding.UTF8);
	}

	public void Dispose()
	{
		_sw.Dispose();
	}

	public async ValueTask DisposeAsync()
	{
		await _sw.DisposeAsync();
	}

	public Task WriteAsync() => Task.Run(() =>
	{
		_sw.Write(
@$"// Copyright Zero Games. All Rights Reserved.

// THIS FILE IS GENERATED BY ZSHARP.
// DO NOT MODIFY DIRECTLY!

#region GENERATED CODE

#nullable enable
#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

{string.Join('\n', NamespaceHelper.LootNamespace(_exportedClass).Where(ns => ns != _exportedClass.Namespace).Select(ns => $"using {ns};"))}

namespace {_exportedClass.Namespace};

{_classAttributes}
{_classDeclaration}{_classBody}

#endregion


");
	});

	private string GetTypeModule(string type)
	{
		string[] split = type.Split('.');
		if (split.Length < 2)
		{
			return string.Empty;
		}

		return split[0];
	}

	private string GetMethodBlock(ExportedMethod method)
	{
		string accessModifier = method.IsPublic ? "public" : method.IsProtected ? "protected" : "private";
		string staticModifier = method.IsStatic ? "static " : string.Empty;
		string returnType = method.ReturnParameter?.Type.ToString() ?? "void";
		List<string> parameters = [];
		List<string> zcallParameters = [];
		List<string> copybackStats = [];
		bool hasReturn = method.ReturnParameter is not null;
		for (int32 i = 0; i < method.Parameters.Count - (hasReturn ? 1 : 0); ++i)
		{
			ExportedParameter param = method.Parameters[i];
			string modifier = param.IsInOut ? "ref " : param.IsOut ? "out " : string.Empty;
			parameters.Add($"{modifier}{param.Type} {param.Name}");

			if (param is { IsOut: true, IsIn: false })
			{
				zcallParameters.Add($"typeof({param.Type.ToString(false)})");
			}
			else
			{
				zcallParameters.Add(param.Name);
			}

			if (param.IsOut)
			{
				int32 index = method.IsStatic ? i : i + 1;
				string nullForgivingModifier = param.Type.IsNullable ? string.Empty : "!";
				string left = param.Name;
				string right = $"({param.Type.ToString()})res[{index}].Object{nullForgivingModifier}";
				copybackStats.Add($"{left} = {right};");
			}
		}
		string parameterList = string.Join(", ", parameters);
		string context = method.IsStatic ? "ZCallEx" : "this";
		string copybacks = string.Join("\n", copybackStats);
		if (copybacks.Length > 0)
		{
			copybacks = copybacks.Insert(0, "\n") + '\n';
		}
		
		string returnNullForgivingModifier = method.ReturnParameter?.Type.IsNullable ?? default ? string.Empty : "!";
		string returnBody = hasReturn ? $" ({returnType})res[-1].Object{returnNullForgivingModifier}" : string.Empty;
		string returnStat = $"return{returnBody};";
		
		string zcallParameterList = string.Join(", ", zcallParameters);
		string returnSeparator = string.IsNullOrWhiteSpace(zcallParameterList) ? string.Empty : ", ";
		string @return = hasReturn ? $"typeof({method.ReturnParameter!.Type.ToString(false)})" : string.Empty;
		string returnParam = hasReturn ? $"{returnSeparator}{@return}" : string.Empty;
		string zcallparam = $"\"{method.ZCallName}\"";
		
		string methodBody = 
@$"DynamicZCallResult res = {context}.ZCall({zcallparam}, [ {zcallParameterList}{returnParam} ]);
{copybacks}
{returnStat}".Indent(2);
		return
@$"	{accessModifier} {staticModifier}{returnType} {method.Name}({parameterList})
	{{
{methodBody}
	}}";
	}

	private string GetPropertyBlock(ExportedProperty property)
	{
		string name = property.Type.ToString();
		bool nullable = property.Type.IsNullable;
		string nullForgivingModifier = nullable ? string.Empty : "!";
		string accessModifier = property.IsPublic ? "public" : property.IsProtected ? "protected" : "private";
		
		string getBlock = property.IsReadable ? @$"get => ({name})this.ZCall(""{property.ZCallName}"", false, {property.Index}, typeof({property.Type.ToString(false)}))[3].Object{nullForgivingModifier};" : string.Empty;
		string setBlock = property.IsWritable ? @$"set => this.ZCall(""{property.ZCallName}"", true, {property.Index}, value);" : string.Empty;
		string lf = string.IsNullOrWhiteSpace(setBlock) ? string.Empty : "\n";
		
		string block =
@$"	{accessModifier} {property.Type} {property.Name}
	{{
{getBlock.Indent(2)}{lf}{setBlock.Indent(2)}
	}}";

		return block;
	}

	private string _classAttributes
	{
		get
		{
			List<string> attrs = [ $"[System.CodeDom.Compiler.GeneratedCode(\"ZSharp\", \"{Assembly.GetExecutingAssembly().GetName().Version!.ToString(3)}\")]" ];
			if (_exportedClass.ConjugateRegistryId > 0)
			{
				attrs.Add($"[ConjugateRegistryId({_exportedClass.ConjugateRegistryId})]");
			}
			
			if (!string.IsNullOrWhiteSpace(_exportedClass.UnrealFieldPath))
			{
				attrs.Add($"[UnrealFieldPath(__UNREAL_FIELD_PATH)]");
			}

			if (_exportedClass.IsHashableStruct)
			{
				attrs.Add("[HashableUnrealStruct]");
			}
			
			return string.Join('\n', attrs);
		}
	}

	private string _classDeclaration
	{
		get
		{
			string @class = _exportedClass.IsInterface ? "interface " : "class ";
			string? @base = _baseType;
			string? conjugate = _hasBuildConjugate ? $"IConjugate<{_exportedClass.Name}>" : null;
			List<string?> bases = [ @base, conjugate ];
			
			string classModifiers = $"public partial {@class}";
			string baseTypes = string.Join(", ", bases.Where(b => b is not null));
			if (!string.IsNullOrWhiteSpace(baseTypes))
			{
				baseTypes = baseTypes.Insert(0, " : ");
			}
			return $"{classModifiers}{_exportedClass.Name}{baseTypes}";
		}
	}

	private bool _hasBuildConjugate => !_exportedClass.IsInterface;

	private string? _baseType
	{
		get
		{
			if (string.IsNullOrWhiteSpace(_exportedClass.BaseType.Name))
			{
				if (_exportedClass.IsPlain)
				{
					return "PlainExportedObjectBase";
				}

				if (_exportedClass.IsClass)
				{
					return "UnrealObjectBase";
				}

				if (_exportedClass.IsStruct)
				{
					return "UnrealStructBase";
				}

				if (_exportedClass.IsInterface)
				{
					return null;
				}

				throw new InvalidOperationException($"Invalid exported class {_exportedClass.Name}");
			}

			return _exportedClass.BaseType.ToString(false);
		}
	}

	private string? _interfaceStaticField
	{
		get
		{
			if (_exportedClass.IsClass | _exportedClass.IsInterface)
			{
				return
@"	public new static string SUnrealFieldPath => __UNREAL_FIELD_PATH;
	public new static UnrealClass SStaticClass => UnrealObjectGlobals.LowLevelFindObject<UnrealClass>(__UNREAL_FIELD_PATH)!;";
			}
			if (_exportedClass.IsStruct)
			{
				return
@"	public new static string SUnrealFieldPath => __UNREAL_FIELD_PATH;
	public new static UnrealScriptStruct SStaticStruct => UnrealObjectGlobals.LowLevelFindObject<UnrealScriptStruct>(__UNREAL_FIELD_PATH)!;";
			}

			return null;
		}
	}

	private string? _interfaceInstanceField
	{
		get
		{
			if (_exportedClass.IsClass | _exportedClass.IsStruct)
			{
				return "\tpublic override string UnrealFieldPath => __UNREAL_FIELD_PATH;";
			}
			
			return null;
		}
	}

	private string? _constructorStatic
	{
		get
		{
			return
@$"	static {_exportedClass.Name}()
	{{

	}}";
		}
	}

	private string _classBody
	{
		get
		{
			StringBuilder body = new();

			// @TODO: Interface needs special support.
			if (!_exportedClass.IsInterface)
			{
				// Methods
				foreach (var method in _exportedClass.Methods.OrderBy(method => method.IsPublic ? 1 : method.IsProtected ? 2 : 3))
				{
					string block = GetMethodBlock(method);
					body.Append(block);
					body.Append("\n\n");
				}
			
				// Properties
				foreach (var prop in _exportedClass.Properties.OrderBy(prop => prop.IsPublic ? 1 : prop.IsProtected ? 2 : 3))
				{
					string block = GetPropertyBlock(prop);
					body.Append(block);
					body.Append("\n\n");
				}
			}

			// Intrinsics
			string userdata = _exportedClass.IsStruct ? "SStaticStruct.Unmanaged" : "IntPtr.Zero";
			string? constructorDefault = _exportedClass.IsClass || _exportedClass.IsInterface ? null : $"\tpublic {_exportedClass.Name}(){{ Unmanaged = GetOwningAlc().BuildConjugate(this, {userdata}); }}";
			string? methodBuildConjugate = _hasBuildConjugate ? $"\tpublic new static {_exportedClass.Name} BuildConjugate(IntPtr unmanaged) => new(unmanaged);" : null;
			string? constructorRed = _exportedClass.IsInterface ? null : $"\tprotected {_exportedClass.Name}(IntPtr unmanaged) : base(unmanaged){{}}";
			string? constUnrealFieldPath = string.IsNullOrWhiteSpace(_exportedClass.UnrealFieldPath) ? null : $"\tprivate const string __UNREAL_FIELD_PATH = \"{_exportedClass.UnrealFieldPath}\";";
			
			List<string?> intrinsicMethods = [ constructorDefault, methodBuildConjugate, _interfaceStaticField, _interfaceInstanceField, constructorRed/*, _constructorStatic*/, constUnrealFieldPath ];
			string intrinsicMethodBlock = string.Join('\n', intrinsicMethods.Where(m => m is not null));
			body.Append(intrinsicMethodBlock);

			if (body.Length > 0)
			{
				body.Insert(0, "\n{\n\n");
				body.Append("\n\n}");
			}
			else
			{
				body.Append(';');
			}

			return body.ToString();
		}
	}

	private ExportedAssemblyRegistry _registry;
	private ExportedClass _exportedClass;
	private StreamWriter _sw;
	
}


