// Copyright Zero Games. All Rights Reserved.

using System.Text;
using System.Xml;

namespace ZeroGames.ZSharp.Build.Solution;

public class ProjectFileBuilder
{
	public ProjectFileBuilder(ProjectDefinition project, string unrealProjectDir, string zsharpPluginDir)
	{
		_project = project;
		_unrealProjectDir = unrealProjectDir;
		_zsharpPluginDir = zsharpPluginDir;
	}

	public override string ToString()
	{
		XmlDocument doc = new();

		BuildHeader(doc);
		XmlElement projectNode = BuildProjectNode(doc);
		BuildPropertyGroupNode(doc, projectNode);
		BuildPropertyGroupByConfiguration(DEBUG_GAME_CONFIGURATION, doc, projectNode);
		BuildPropertyGroupByConfiguration(DEVELOPMENT_CONFIGURATION, doc, projectNode);
		BuildPropertyGroupByConfiguration(SHIPPING_CONFIGURATION, doc, projectNode);
		BuildItemGroupNode(doc, projectNode);
		BuildReferenceNode(doc, projectNode);
		BuildTargetNode(doc, projectNode);

		XmlWriterSettings xws = new()
		{
			Encoding = Encoding.UTF8,
			Indent = true,
			IndentChars = "\t",
			OmitXmlDeclaration = true,
			CloseOutput = false,
		};
		using MemoryStream ms = new MemoryStream();
		using XmlWriter xw = XmlWriter.Create(ms, xws);
		using StreamReader sr = new(ms, Encoding.UTF8);
		doc.Save(xw);
		ms.Position = 0;

		return sr.ReadToEnd();
	}

	private static void AppendSimpleChild(XmlDocument doc, XmlElement elem, string childName, string childInnerText)
	{
		XmlElement childNode = doc.CreateElement(childName);
		childNode.InnerText = childInnerText;
		elem.AppendChild(childNode);
	}

	private void BuildHeader(XmlDocument doc)
	{
		doc.AppendChild(doc.CreateComment("Copyright Zero Games. All Rights Reserved."));

		doc.AppendChild(doc.CreateComment("THIS FILE IS GENERATED BY ZSHARP."));
		doc.AppendChild(doc.CreateComment("DO NOT MODIFY DIRECTLY!"));
	}

	private XmlElement BuildProjectNode(XmlDocument doc)
	{
		XmlElement projectNode = doc.CreateElement("Project");
		projectNode.SetAttribute("Sdk", "Microsoft.NET.Sdk");
		doc.AppendChild(projectNode);

		return projectNode;
	}

	private XmlElement BuildPropertyGroupNode(XmlDocument doc, XmlElement projectNode)
	{
		XmlElement propertyGroupNode = doc.CreateElement("PropertyGroup");

		void Append(string childName, string childInnerText)
		{
			if (!string.IsNullOrWhiteSpace(childInnerText))
			{
				AppendSimpleChild(doc, propertyGroupNode, childName, childInnerText); 
			}
		}
		
		Append("ProjectName", _project.Name);
		Append("TargetFramework", _project.IsRoslynComponent ? "netstandard2.0" : _project.TargetFramework ?? "net9.0");
		Append("LangVersion", _project.LanguageVersion ?? "13");
		Append("RootNamespace", _project.RootNamespace ?? _project.Name);
		Append("ImplicitUsings", "disable");
		Append("Nullable", _project.IsNullable ? "enable" : "disable");
		Append("AllowUnsafeBlocks", _project.IsUnsafeBlockEnabled.ToString().ToLower());
		Append("Authors", _project.Authors);
		Append("Company", _project.Company);
		Append("AssemblyVersion", _project.AssemblyVersion);
		Append("FileVersion", _project.FileVersion);
		Append("NeutralLanguage", _project.NeutralLanguage);
		if (_project.IsRoslynComponent)
		{
			Append("IsRoslynComponent", "true");
			Append("EnforceExtendedAnalyzerRules", "true");
		}

		List<string> finalWarningsToErros = [.._project.WarningsAsErrors];
		if (_project.IsStrongRestrictedNullable)
		{
			finalWarningsToErros.Add("CS8600;CS8601;CS8602;CS8603;CS8604;CS8609;CS8610;CS8614;CS8616;CS8618;CS8619;CS8622;CS8625;CS8629;CS8777");
		}

		finalWarningsToErros.Insert(0, "$(WarningsAsErrors)");
		Append("WarningsAsErrors", string.Join(';', finalWarningsToErros));
		Append("Configurations", "DebugGame;Development;Shipping");
		Append("Platforms", "AnyCPU");
		Append("UnrealProjectDir", _unrealProjectDir);
		Append("ZSharpProjectDir", $"{_unrealProjectDir}/Intermediate/ZSharp/ProjectFiles");
		Append("ZSharpDir", _zsharpPluginDir);
		Append("SourceDir", _project.SourceDir);
		if (_project.HasGlue)
		{
			Append("GlueDir", $"{_unrealProjectDir}/Intermediate/ZSharp/Glue/{_project.Name}");
		}
		Append("Tags", string.Join(';', _project.Tags));

		projectNode.AppendChild(propertyGroupNode);
		return propertyGroupNode;
	}

	private XmlElement BuildPropertyGroupByConfiguration(string config, XmlDocument doc, XmlElement projectNode)
	{
		XmlElement propertyGroupNode = doc.CreateElement("PropertyGroup");
		propertyGroupNode.SetAttribute("Condition", $" '$(Configuration)' == '{config}' ");
		void Append(string childName, string childInnerText) => AppendSimpleChild(doc, propertyGroupNode, childName, childInnerText);
		Append("Optimize", config switch
		{
			DEBUG_GAME_CONFIGURATION => "false",
			_ => "true"
		});
		Append("DebugSymbols", config switch
		{
			SHIPPING_CONFIGURATION => "false",
			_ => "true"
		});
		Append("DebugType", config switch
		{
			SHIPPING_CONFIGURATION => "none",
			_ => "embedded"
		});

		string[] constants =
		[
			"TRACE",
			config switch
			{
				DEBUG_GAME_CONFIGURATION => "DEBUG;UE_LOG;ASSERTION_CHECK;ASSERTION_CHECK_SLOW",
				DEVELOPMENT_CONFIGURATION => "DEBUG;UE_LOG;ASSERTION_CHECK",
				SHIPPING_CONFIGURATION => "RELEASE",
				_ => throw new InvalidOperationException()
			}
		];
		IEnumerable<string> finalConstants = constants.Concat(config switch
		{
			DEBUG_GAME_CONFIGURATION => _project.DebugGameConstants,
			DEVELOPMENT_CONFIGURATION => _project.DevelopmentConstants,
			SHIPPING_CONFIGURATION => _project.ShippingConstants,
			_ => throw new InvalidOperationException()
		});
		Append("DefineConstants", string.Join(';', finalConstants));

		Dictionary<string, string> propertyMap = config switch
		{
			DEBUG_GAME_CONFIGURATION => _project.DebugGamePropertyMap,
			DEVELOPMENT_CONFIGURATION => _project.DevelopmentPropertyMap,
			SHIPPING_CONFIGURATION => _project.ShippingPropertyMap,
			_ => throw new InvalidOperationException()
		};
		foreach (var pair in propertyMap)
		{
			Append(pair.Key, pair.Value);
		}

		projectNode.AppendChild(propertyGroupNode);
		return propertyGroupNode;
	}

	private XmlElement BuildItemGroupNode(XmlDocument doc, XmlElement projectNode)
	{
		XmlElement itemGroupNode = doc.CreateElement("ItemGroup");

		List<string> finalUsings = [ "System", "System.Collections.Generic", "System.Linq", .._project.Usings ];

		foreach (var us in finalUsings.Distinct())
		{
			XmlElement usingNode = doc.CreateElement("Using");
			usingNode.SetAttribute("Include", us);
			itemGroupNode.AppendChild(usingNode);
		}

		List<string> finalStaticUsings = [ .._project.StaticUsings ];
		if (_project.Name == CORE_ASSEMBLY_NAME || _project.ProjectReferences.Contains(CORE_ASSEMBLY_NAME))
		{
			finalStaticUsings.Add("ZeroGames.ZSharp.Core.CoreGlobals");
			finalStaticUsings.Add("ZeroGames.ZSharp.Core.AssertionMacros");
			finalStaticUsings.Add("ZeroGames.ZSharp.Core.LogMacros");
			finalStaticUsings.Add("ZeroGames.ZSharp.Core.ZSharpLogChannels");
		}

		if (_project.Name == ENGINE_ASSEMBLY_NAME || _project.ProjectReferences.Contains(ENGINE_ASSEMBLY_NAME))
		{
			finalStaticUsings.Add("ZeroGames.ZSharp.UnrealEngine.CoreUObject.UObjectGlobals");
		}

		foreach (var us in finalStaticUsings.Distinct())
		{
			XmlElement aliasNode = doc.CreateElement("Using");
			aliasNode.SetAttribute("Include", us);
			aliasNode.SetAttribute("Static", "true");
			itemGroupNode.AppendChild(aliasNode);
		}

		Dictionary<string, string> intrinsicAliases = new()
		{
			{ "System.Byte", nameof(uint8) },
			{ "System.UInt16", nameof(uint16) },
			{ "System.UInt32", nameof(uint32) },
			{ "System.UInt64", nameof(uint64) },
			{ "System.SByte", nameof(int8) },
			{ "System.Int16", nameof(int16) },
			{ "System.Int32", nameof(int32) },
			{ "System.Int64", nameof(int64) },
		};

		foreach (var pair in intrinsicAliases.Concat(_project.Aliases).DistinctBy(pair => pair.Key))
		{
			XmlElement aliasNode = doc.CreateElement("Using");
			aliasNode.SetAttribute("Include", pair.Key);
			aliasNode.SetAttribute("Alias", pair.Value);
			itemGroupNode.AppendChild(aliasNode);
		}

		projectNode.AppendChild(itemGroupNode);
		return itemGroupNode;
	}

	private XmlElement BuildReferenceNode(XmlDocument doc, XmlElement projectNode)
	{
		XmlElement itemGroupNode = doc.CreateElement("ItemGroup");

		if (_project.IsRoslynComponent)
		{
			{
				XmlElement referenceNode = doc.CreateElement("PackageReference");
				referenceNode.SetAttribute("Include", "Microsoft.CodeAnalysis.CSharp");
				referenceNode.SetAttribute("Version", "4.11.0");
				referenceNode.SetAttribute("PrivateAssets", "all");
				itemGroupNode.AppendChild(referenceNode);
			}
			
			{
				XmlElement referenceNode = doc.CreateElement("PackageReference");
				referenceNode.SetAttribute("Include", "Microsoft.CodeAnalysis.Analyzers");
				referenceNode.SetAttribute("Version", "3.11.0");
				referenceNode.SetAttribute("PrivateAssets", "all");
				itemGroupNode.AppendChild(referenceNode);
			}
		}

		List<string> finalProjectReferences = [.._project.ProjectReferences];
		if (_project.HasGlue)
		{
			finalProjectReferences.Add(CORE_ASSEMBLY_NAME);
		}
		foreach (var reference in finalProjectReferences.Distinct())
		{
			XmlElement referenceNode = doc.CreateElement("ProjectReference");
			referenceNode.SetAttribute("Include", $"$(ZSharpProjectDir)/{reference}/{reference}.csproj");
			itemGroupNode.AppendChild(referenceNode);
		}

		List<string> finalProjectAnalyzerReferences = [.._project.ProjectAnalyzerReferences];
		if (!_project.IsRoslynComponent)
		{
			if (_project.UsesZSharpAnalyzer)
			{
				string analyzerProjectName = _project.ProjectType switch
				{
					EProjectType.CSharp => "ZeroGames.ZSharp.Analyzer.CSharp",
					EProjectType.VisualBasic => throw new NotImplementedException(),
					_ => throw new InvalidOperationException()
				};
				finalProjectAnalyzerReferences.Add(analyzerProjectName);
			}

			if (_project.ProjectReferences.Contains("ZeroGames.ZSharp.Emit") && !_project.ForceNoEmitSourceGenerator)
			{
				string sourceGeneratorProjectName = _project.ProjectType switch
				{
					EProjectType.CSharp => "ZeroGames.ZSharp.Emit.SourceGenerator.CSharp",
					EProjectType.VisualBasic => throw new NotImplementedException(),
					_ => throw new InvalidOperationException()
				};
				finalProjectAnalyzerReferences.Add(sourceGeneratorProjectName);
			}
		}
		
		foreach (var reference in finalProjectAnalyzerReferences.Distinct())
		{
			XmlElement referenceNode = doc.CreateElement("ProjectReference");
			referenceNode.SetAttribute("Include", $"$(ZSharpProjectDir)/{reference}/{reference}.csproj");
			referenceNode.SetAttribute("OutputItemType", "Analyzer");
			referenceNode.SetAttribute("ReferenceOutputAssembly", "false");
			itemGroupNode.AppendChild(referenceNode);
		}

		List<string> finalExternalReferences = [.._project.ExternalReferences];
		foreach (var reference in finalExternalReferences.Distinct())
		{
			string postfix = reference.EndsWith(".dll") ? string.Empty : ".dll";
			string dllPath = $"$(SourceDir)/{reference}{postfix}";
			string dllName = Path.GetFileNameWithoutExtension(dllPath);

			XmlElement referenceNode = doc.CreateElement("Reference");
			referenceNode.SetAttribute("Include", dllName);
			XmlElement hintPathNode = doc.CreateElement("HintPath");
			hintPathNode.InnerText = dllPath;
			referenceNode.AppendChild(hintPathNode);
			itemGroupNode.AppendChild(referenceNode);
		}
		
		List<string> finalExternalAnalyzerReferences = [.._project.ExternalAnalyzerReferences];
		foreach (var reference in finalExternalAnalyzerReferences.Distinct())
		{
			string postfix = reference.EndsWith(".dll") ? string.Empty : ".dll";
			string dllPath = $"$(SourceDir)/{reference}{postfix}";
			string dllName = Path.GetFileNameWithoutExtension(dllPath);

			XmlElement referenceNode = doc.CreateElement("Reference");
			referenceNode.SetAttribute("Include", dllName);
			referenceNode.SetAttribute("OutputItemType", "Analyzer");
			referenceNode.SetAttribute("ReferenceOutputAssembly", "false");
			XmlElement hintPathNode = doc.CreateElement("HintPath");
			hintPathNode.InnerText = dllPath;
			referenceNode.AppendChild(hintPathNode);
			itemGroupNode.AppendChild(referenceNode);
		}
		
		XmlElement compileNode = doc.CreateElement("Compile");
		compileNode.SetAttribute("Include", "$(SourceDir)/**/*.cs");
		itemGroupNode.AppendChild(compileNode);
		
		XmlElement contentNode = doc.CreateElement("Content");
		contentNode.SetAttribute("Include", "$(SourceDir)/$(ProjectName).zsproj");
		XmlElement contentLinkNode = doc.CreateElement("Link");
		contentLinkNode.InnerText = $"{_project.Name}.zsproj";
		contentNode.AppendChild(contentLinkNode);
		itemGroupNode.AppendChild(contentNode);

		if (_project is { IsRoslynComponent: true, HasAnalyzerReleaseTracking: true })
		{
			{
				XmlElement additionalNode = doc.CreateElement("AdditionalFiles");
				additionalNode.SetAttribute("Include", "$(SourceDir)/AnalyzerReleases.Shipped.md");
				itemGroupNode.AppendChild(additionalNode);
			}
			
			{
				XmlElement additionalNode = doc.CreateElement("AdditionalFiles");
				additionalNode.SetAttribute("Include", "$(SourceDir)/AnalyzerReleases.Unshipped.md");
				itemGroupNode.AppendChild(additionalNode);
			}
		}
		
		if (_project.HasGlue)
		{
			XmlElement glueNode = doc.CreateElement("Compile");
			glueNode.SetAttribute("Include", "$(GlueDir)/**/*.cs");
			itemGroupNode.AppendChild(glueNode);
		}

		projectNode.AppendChild(itemGroupNode);
		return itemGroupNode;
	}

	private XmlElement BuildTargetNode(XmlDocument doc, XmlElement projectNode)
	{
		XmlElement targetNode = doc.CreateElement("Target");
		
		if (_project.IsRoslynComponent)
		{
			return targetNode;
		}

		void AddPostBuildCommand(string command)
		{
			XmlElement mkdirNode = doc.CreateElement("Exec");
			mkdirNode.SetAttribute("Command", command);
			targetNode.AppendChild(mkdirNode);
		}
		
		void AddCopyTarget(string targetDir)
		{
			AddPostBuildCommand($"if not exist \"{targetDir}\" mkdir \"{targetDir}\"");
			AddPostBuildCommand($"copy \"$(TargetPath)\" \"{targetDir}/$(TargetFileName)\"");
		}
		
		targetNode.SetAttribute("Name", "PostBuild");
		targetNode.SetAttribute("AfterTargets", "PostBuildEvent");

		bool isPrecompiled = _project.IsPrecompiled;
		string additionalPath = string.Empty;
		if (_project.IsCore)
		{
			additionalPath = "/Core";
			isPrecompiled = true;
		}
		else if (_project.IsForwardShared)
		{
			additionalPath = "/ForwardShared";
			isPrecompiled = true;
		}
		else if (_project.IsDeferredShared)
		{
			additionalPath = "/DeferredShared";
			isPrecompiled = true;
		}
		
		AddCopyTarget($"$(UnrealProjectDir)/Binaries/Managed{additionalPath}");
		if (isPrecompiled)
		{
			AddCopyTarget($"$(ZSharpDir)/Precompiled{additionalPath}");
		}

		foreach (var command in _project.PostBuildCommands)
		{
			AddPostBuildCommand(command);
		}

		projectNode.AppendChild(targetNode);
		return targetNode;
	}

	private const string CORE_ASSEMBLY_NAME = "ZeroGames.ZSharp.Core";
	private const string ENGINE_ASSEMBLY_NAME = "ZeroGames.ZSharp.UnrealEngine";

	private const string DEBUG_GAME_CONFIGURATION = "DebugGame";
	private const string DEVELOPMENT_CONFIGURATION = "Development";
	private const string SHIPPING_CONFIGURATION = "Shipping";

	private ProjectDefinition _project;
	private string _unrealProjectDir;
	private string _zsharpPluginDir;
}


